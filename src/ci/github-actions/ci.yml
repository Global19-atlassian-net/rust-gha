######################################################
#   WARNING! Action needed when changing this file   #
######################################################

# Due to GitHub Actions limitations, we can't use YAML Anchors directly in the
# CI configuration stored on the repository. To work around that this file is
# expanded by a tool in the repository, and the expansion is committed as well.
#
# After you make any change to the file you'll need to run this command:
#
#   ./x.py run src/tools/expand-yaml-anchors
#
# ...and commit the file it updated in addition to this one. If you forget this
# step CI will fail.

---

###############################
#   YAML Anchors Definition   #
###############################

# This key contains most of the YAML anchors that will be used later in the
# document. YAML anchors allows us to greatly reduce duplication inside the CI
# configuration by reusing parts of the configuration.
#
# YAML anchors work by defining an anchor with `&anchor-name` and reusing its
# content in another place with `*anchor-name`. The special `<<` map key merges
# the content of the map with the content of the anchor (or list of anchors).
#
# The expand-yaml-anchors tool will automatically remove this block from the
# output YAML file.
x--expand-yaml-anchors--remove:

  - &shared-ci-variables
    CI_JOB_NAME: ${{ matrix.name }}

  - &public-variables
    SCCACHE_BUCKET: rust-lang-gha-caches
    TOOLSTATE_REPO: https://github.com/pietroalbini/rust-toolstate

  - &prod-variables
    SCCACHE_BUCKET: rust-lang-gha-caches
    DEPLOY_BUCKET: rust-lang-gha
    TOOLSTATE_REPO: https://github.com/pietroalbini/rust-toolstate
    TOOLSTATE_ISSUES_API_URL: https://api.github.com/repos/pietroalbini/rust-toolstate/issues
    TOOLSTATE_PUBLISH: 1
    # AWS_SECRET_ACCESS_KEYs are stored in GitHub's secrets storage, named
    # AWS_SECRET_ACCESS_KEY_<keyid>. Including the key id in the name allows to
    # rotate them in a single branch while keeping the old key in another
    # branch, which wouldn't be possible if the key was named with the kind
    # (caches, artifacts...).
    CACHES_AWS_ACCESS_KEY_ID: AKIA46X5W6CZOMUQATD5
    ARTIFACTS_AWS_ACCESS_KEY_ID: AKIA46X5W6CZH5AYXDVF

  - &base-job
    env: {}

  - &job-linux-xl
    os: ubuntu-latest-xl
    <<: *base-job

  - &job-macos-xl
    os: macos-latest  # We don't have an XL builder for this
    <<: *base-job

  - &job-windows-xl
    os: windows-latest-xl
    <<: *base-job

  - &step
    if: success() && !env.SKIP_JOB

  - &step-run
    <<: *step
    shell: bash

  - &base-ci-job
    timeout-minutes: 600
    runs-on: "${{ matrix.os }}"
    env: *shared-ci-variables
    steps:
      - name: configure GitHub Actions to kill the build when outdated
        uses: rust-lang/simpleinfra/github-actions/cancel-outdated-builds@master
        with:
          github_token: "${{ secrets.github_token }}"
        <<: *step

      - name: disable git crlf conversion
        run: git config --global core.autocrlf false
        <<: *step-run

      - name: checkout the source code
        uses: actions/checkout@v1
        with:
          fetch-depth: 2
        <<: *step

      - name: add extra enviornment variables
        run: src/ci/scripts/setup-environment.sh
        env:
          # Since it's not possible to merge `${{ matrix.env }}` with the other
          # variables in `job.<name>.env`, the variables defined in the matrix
          # are passed to the `setup-environment.sh` script encoded in JSON,
          # which then uses log commands to actually set them.
          EXTRA_VARIABLES: ${{ toJson(matrix.env) }}
        <<: *step-run

      - name: decide whether to skip this job
        run: src/ci/scripts/should-skip-this.sh
        <<: *step-run

      - name: collect CPU statistics
        run: src/ci/scripts/collect-cpu-stats.sh
        <<: *step-run

      - name: show the current environment
        run: src/ci/scripts/dump-environment.sh
        <<: *step-run

      - name: install awscli
        run: src/ci/scripts/install-awscli.sh
        <<: *step-run

      - name: install sccache
        run: src/ci/scripts/install-sccache.sh
        <<: *step-run

      - name: install clang
        run: src/ci/scripts/install-clang.sh
        <<: *step-run

      - name: switch xcode version
        run: src/ci/scripts/switch-xcode.sh
        <<: *step-run

      - name: install WIX
        run: src/ci/scripts/install-wix.sh
        <<: *step-run

      - name: install InnoSetup
        run: src/ci/scripts/install-innosetup.sh
        <<: *step-run

      - name: "ensure builds happens inside of C: instead of D:"
        run: src/ci/scripts/windows-symlink-build-dir.sh
        <<: *step-run

      - name: disable git crlf conversion
        run: src/ci/scripts/disable-git-crlf-conversion.sh
        <<: *step-run

      - name: install MSYS2
        run: src/ci/scripts/install-msys2.sh
        <<: *step-run

      - name: install MSYS2 packages
        run: src/ci/scripts/install-msys2-packages.sh
        <<: *step-run

      - name: install MinGW
        run: src/ci/scripts/install-mingw.sh
        <<: *step-run

      - name: install ninja
        run: src/ci/scripts/install-ninja.sh
        <<: *step-run

      - name: enable ipv6 on Docker
        run: src/ci/scripts/enable-docker-ipv6.sh
        <<: *step-run

      # Disable automatic line ending conversion (again). On Windows, when we're
      # installing dependencies, something switches the git configuration directory or
      # re-enables autocrlf. We've not tracked down the exact cause -- and there may
      # be multiple -- but this should ensure submodules are checked out with the
      # appropriate line endings.
      - name: disable git crlf conversion
        run: src/ci/scripts/disable-git-crlf-conversion.sh
        <<: *step-run

      - name: checkout submodules
        run: src/ci/scripts/checkout-submodules.sh
        <<: *step-run

      - name: ensure line endings are correct
        run: src/ci/scripts/verify-line-endings.sh
        <<: *step-run

      - name: run the build
        run: src/ci/scripts/run-build-from-ci.sh
        env:
          AWS_ACCESS_KEY_ID: ${{ env.CACHES_AWS_ACCESS_KEY_ID }}
          AWS_SECRET_ACCESS_KEY: ${{ secrets[format('AWS_SECRET_ACCESS_KEY_{0}', env.CACHES_AWS_ACCESS_KEY_ID)] }}
          TOOLSTATE_REPO_ACCESS_TOKEN: ${{ secrets.TOOLSTATE_REPO_ACCESS_TOKEN }}
        <<: *step-run

      - name: upload artifacts to S3
        run: src/ci/scripts/upload-artifacts.sh
        env:
          AWS_ACCESS_KEY_ID: ${{ env.ARTIFACTS_AWS_ACCESS_KEY_ID }}
          AWS_SECRET_ACCESS_KEY: ${{ secrets[format('AWS_SECRET_ACCESS_KEY_{0}', env.ARTIFACTS_AWS_ACCESS_KEY_ID)] }}
        # Adding a condition on DEPLOY=1 or DEPLOY_ALT=1 is not needed as all deploy
        # builders *should* have the AWS credentials available. Still, explicitly
        # adding the condition is helpful as this way CI will not silently skip
        # deploying artifacts from a dist builder if the variables are misconfigured,
        # erroring about invalid credentials instead.
        if: success() && !env.SKIP_JOB && (github.event_name == 'pull' || env.DEPLOY == '1' || env.DEPLOY_ALT == '1')
        <<: *step-run

###########################
#   Builders definition   #
###########################

name: CI
on:
  push:
    branches:
      - auto
      - try
      - master
  pull_request:
    branches:
      - "**"

jobs:
  pr:
    <<: *base-ci-job
    name: PR
    env:
      <<: [*public-variables, *shared-ci-variables]
    if: github.event_name == 'pull_request'
    strategy:
      matrix:
        name:
          - mingw-check
          - x86_64-gnu-llvm-6.0
          - x86_64-gnu-tools
        include:
          - name: mingw-check
            <<: *job-linux-xl

          - name: x86_64-gnu-llvm-6.0
            <<: *job-linux-xl

          - name: x86_64-gnu-tools
            env:
              CI_ONLY_WHEN_SUBMODULES_CHANGED: 1
            <<: *job-linux-xl

  try:
    <<: *base-ci-job
    name: try
    env:
      <<: [*prod-variables, *shared-ci-variables]
    if: github.event_name == 'push' && github.ref == 'refs/heads/try'
    strategy:
      matrix:
        name:
          - dist-x86_64-linux
          - dist-x86_64-linux-alt
        include:
          - name: dist-x86_64-linux
            <<: *job-linux-xl

          - name: dist-x86_64-linux-alt
            env:
              IMAGE: dist-x86_64-linux
            <<: *job-linux-xl

  master:
    name: master
    runs-on: ubuntu-latest
    env:
      <<: [*prod-variables]
    if: github.event_name == 'push' && github.ref == 'refs/heads/master'
    steps:
      - name: checkout the source code
        uses: actions/checkout@v1
        with:
          fetch-depth: 2

      - name: publish toolstate
        run: src/ci/scripts/publish-toolstate.sh
        env:
          TOOLSTATE_REPO_ACCESS_TOKEN: ${{ secrets.TOOLSTATE_REPO_ACCESS_TOKEN }}
        <<: *step-run
